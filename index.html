<!doctype html>
<html lang="pt-br">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Chat Canvas + GPT</title>
<style>
  :root {
    --tiffany:#81D8D0;
    --bg:#0f1216;
    --card:#151a21;
    --text:#eaf2fb;
    --muted:#9fb3c8;
    --border:#243041;
  }

  * , *::before, *::after {
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
  }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font: 16px/1.45 system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  }

  .wrap {
    width: 100%;
    max-width: 1100px;
    margin: 0 auto;
    padding: 24px 24px 32px;
    height: 100%;
    display: flex;
  }

  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,.25);
    display: flex;
    flex-direction: column;
    width: 100%;
    min-height: 0;
  }

  .header {
    padding: 14px 16px;
    border-bottom: 1px solid var(--border);
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }

  .left {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: var(--tiffany);
  }

  .title {
    font-weight: 600;
  }

  .badge {
    padding: 6px 10px;
    border-radius: 999px;
    background: #f1f5f9;
    color: #0f172a;
    font: 500 12px system-ui;
    box-shadow: 0 1px 3px rgba(0,0,0,.08);
    white-space: nowrap;
  }

  .tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    gap: 4px;
    padding: 0 8px;
    flex-shrink: 0;
  }

  .tab-btn {
    border: 0;
    background: transparent;
    color: var(--muted);
    padding: 10px 14px;
    cursor: pointer;
    font-weight: 500;
    border-radius: 999px;
    margin: 6px 4px;
  }

  .tab-btn.active {
    background: rgba(129,216,208,0.12);
    color: var(--text);
    border: 1px solid var(--tiffany);
  }

  .panel {
    display: none;
    flex-direction: column;
    flex: 1 1 auto;
    min-height: 0;
  }

  .panel.active {
    display: flex;
  }

  .chat {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    overflow-y: auto;
    flex: 1 1 auto;
    min-height: 0;
  }

  .msg {
    max-width: 80%;
    padding: 10px 12px;
    border: 1px solid var(--border);
    border-radius: 12px;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .user {
    align-self: flex-end;
    background: rgba(129,216,208,.12);
  }

  .bot {
    align-self: flex-start;
    background: #0d1117;
  }

  .footer {
    display: flex;
    gap: 8px;
    padding: 12px 12px 14px;
    border-top: 1px solid var(--border);
    align-items: center;
    flex-shrink: 0;
  }

  input, button {
    font: inherit;
  }

  input {
    flex: 1;
    background: #0d1117;
    color: var(--text);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 10px;
    font-size: 16px;
    min-width: 0;
  }

  button {
    background: var(--tiffany);
    border: 0;
    border-radius: 10px;
    padding: 12px 16px;
    color: #0b1f1e;
    cursor: pointer;
    font-weight: 700;
    white-space: nowrap;
  }

  button:disabled {
    opacity: .6;
    cursor: not-allowed;
  }

  .cta-wrap {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-top: 6px;
  }

  .cta-btn {
    display: inline-block;
    background: #81D8D0;
    color: #0b1f1e;
    padding: 8px 14px;
    border-radius: 999px;
    border: 0;
    text-decoration: none;
    font-weight: 700;
    box-shadow: 0 1px 3px rgba(0,0,0,.1);
  }

  .cta-btn:hover {
    filter: brightness(0.95);
  }

  .speaking-wrap {
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow-y: auto;
    flex: 1 1 auto;
    min-height: 0;
  }

  .speaking-card {
    background: #0d1117;
    border-radius: 12px;
    border: 1px solid var(--border);
    padding: 12px 14px;
    font-size: 14px;
    color: var(--muted);
    white-space: pre-wrap;
  }

  .speaking-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .speaking-btn {
    background: rgba(129,216,208,.15);
    color: var(--text);
    border-radius: 999px;
    padding: 8px 14px;
    border: 1px solid var(--tiffany);
    cursor: pointer;
    font-size: 14px;
  }

  .speaking-btn:disabled {
    opacity: .6;
    cursor: not-allowed;
  }

  .speaking-status {
    font-size: 13px;
    color: var(--muted);
    margin-top: 8px;
    white-space: pre-wrap;
  }

  .speaking-audio {
    margin-top: 8px;
  }

  @media (max-width: 600px) {
    .wrap {
      padding: 8px;
    }
    .header {
      padding: 10px 12px;
    }
    .footer {
      padding: 10px 10px 12px;
      gap: 6px;
    }
    input {
      padding: 10px 8px;
      font-size: 15px;
    }
    button {
      padding: 10px 12px;
      font-size: 15px;
    }
    .msg {
      max-width: 90%;
    }
  }
</style>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div class="left">
          <span class="dot"></span>
          <div class="title">IA English Journey</div>
        </div>
        <div id="quota-badge" class="badge">carregando‚Ä¶</div>
      </div>

      <div class="tabs">
        <button id="tab-chat" class="tab-btn active">Chat</button>
        <button id="tab-speaking" class="tab-btn">Speaking Lab</button>
      </div>

      <div id="panel-chat" class="panel active">
        <div id="chat" class="chat"></div>
        <div class="footer">
          <input id="input" placeholder="Ask your questions..." autocomplete="off" autocapitalize="sentences" />
          <button id="send">Enviar</button>
        </div>
      </div>

      <div id="panel-speaking" class="panel">
        <div class="speaking-wrap">
          <div class="speaking-card">
            <strong>Speaking Lab (beta)</strong>
            <br><br>
            Grave frases em ingl√™s para praticar sua pron√∫ncia.
            Exemplo: <em>"Do you speak Spanish, my friend?"</em>
            <br><br>
            Ao terminar a grava√ß√£o, o sistema vai:
            <br>‚Ä¢ transcrever aproximadamente o que voc√™ falou;
            <br>‚Ä¢ mostrar a frase correta em ingl√™s;
            <br>‚Ä¢ dar uma dica r√°pida em portugu√™s sobre a pron√∫ncia;
            <br>‚Ä¢ e tocar a frase corrigida em voz de IA.
          </div>

          <div class="speaking-card">
            <div class="speaking-actions">
              <button id="rec-start" class="speaking-btn">üéôÔ∏è Gravar</button>
              <button id="rec-stop" class="speaking-btn" disabled>‚èπÔ∏è Parar</button>
            </div>
            <div id="speech-status" class="speaking-status">
Pronto para gravar. Clique em "Gravar", fale em ingl√™s e depois clique em "Parar".
            </div>
            <!-- texto minimalista com uso de √°udio -->
            <div id="speech-usage" class="speaking-status"></div>

            <audio id="speech-playback" class="speaking-audio" controls style="display:none"></audio>
            <audio id="speech-tts" class="speaking-audio" controls style="display:none"></audio>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const CHAT_URL     = '/api/chat';
  const QUOTA_URL    = '/api/quota';
  const SPEAKING_URL = '/api/speaking';

  const LOCAL_HISTORY_KEY = 'ia_english_history_v1';

  function captureTokenFromURL(){
    try {
      const u = new URL(window.location.href);
      const t = u.searchParams.get('t');
      if (t) {
        localStorage.setItem('lti_token', t);
        u.searchParams.delete('t');
        window.history.replaceState({}, '', u.toString());
      }
      return t;
    } catch {
      return null;
    }
  }

  function getToken(){
    try {
      return localStorage.getItem('lti_token') || captureTokenFromURL() || null;
    } catch {
      return captureTokenFromURL() || null;
    }
  }

  const SYSTEM_MESSAGES = [
    {
      role: "system",
      content: "Voc√™ √© um tutor de ingles que vai tirar duvidas dos alunos, seja claro e objetivo."
    }
  ];

  async function init() {
    const chat        = document.getElementById('chat');
    const input       = document.getElementById('input');
    const btn         = document.getElementById('send');
    const badge       = document.getElementById('quota-badge');

    const tabChat     = document.getElementById('tab-chat');
    const tabSpeaking = document.getElementById('tab-speaking');
    const panelChat   = document.getElementById('panel-chat');
    const panelSpeak  = document.getElementById('panel-speaking');

    const recStart    = document.getElementById('rec-start');
    const recStop     = document.getElementById('rec-stop');
    const speechStatus= document.getElementById('speech-status');
    const speechUsage = document.getElementById('speech-usage');
    const speechAudio = document.getElementById('speech-playback');
    const speechTTS   = document.getElementById('speech-tts');

    if (!chat || !input || !btn || !badge) {
      console.error('Elementos do chat n√£o encontrados');
      return;
    }

    const messages = [...SYSTEM_MESSAGES];

    // --- estado global para o badge ---
    let activeTab   = 'chat';
    let lastQuota   = null; // {remaining, limit}
    let audioUsage  = null; // {usedSeconds, limitSeconds, label}

    function formatMinutes(num) {
      return num.toFixed(1).replace('.', ',');
    }

    function updateBadge() {
      if (!badge) return;

      if (activeTab === 'chat') {
        if (lastQuota) {
          badge.textContent = `Restantes: ${lastQuota.remaining} / ${lastQuota.limit}`;
        } else {
          badge.textContent = 'carregando‚Ä¶';
        }
      } else {
        if (audioUsage && audioUsage.label) {
          badge.textContent = audioUsage.label;
        } else {
          // antes de qualquer grava√ß√£o, assume 0 / 20 min como refer√™ncia
          badge.textContent = 'Restante: 0,0 / 20 minutos';
        }
      }
    }

    function addMsg(text, who){
      const el = document.createElement('div');
      el.className = `msg ${who}`;
      el.textContent = text;
      chat.appendChild(el);
      chat.scrollTop = chat.scrollHeight;
    }

    function saveLocalHistory(role, content) {
      try {
        const raw = localStorage.getItem(LOCAL_HISTORY_KEY);
        let arr = [];
        if (raw) {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) arr = parsed;
        }
        arr.push({ role, content, ts: Date.now() });
        if (arr.length > 200) {
          arr = arr.slice(arr.length - 200);
        }
        localStorage.setItem(LOCAL_HISTORY_KEY, JSON.stringify(arr));
      } catch (e) {
        console.error('Erro ao salvar hist√≥rico local:', e);
      }
    }

    function loadLocalHistory() {
      try {
        const raw = localStorage.getItem(LOCAL_HISTORY_KEY);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return;

        arr.forEach(m => {
          if (!m || typeof m.content !== 'string') return;
          const who = m.role === 'user' ? 'user' : 'bot';
          addMsg(m.content, who);
          const role = who === 'user' ? 'user' : 'assistant';
          messages.push({ role, content: m.content });
        });
      } catch (e) {
        console.error('Erro ao carregar hist√≥rico local:', e);
      }
    }

    async function atualizarQuota(){
      try {
        const t = getToken();
        const url = t ? `${QUOTA_URL}?t=${encodeURIComponent(t)}` : QUOTA_URL;
        const r = await fetch(url, { credentials: 'include' });
        if (!r.ok) {
          if (r.status === 401) {
            badge.textContent = 'entre pelo Canvas';
            return;
          }
          throw new Error('quota not ok');
        }
        const { remaining, limit } = await r.json();
        lastQuota = { remaining, limit };
        if (activeTab === 'chat') {
          updateBadge();
        }
      } catch (e) {
        console.error('Erro ao buscar quota:', e);
        if (activeTab === 'chat') {
          badge.textContent = 'quota indispon√≠vel';
        }
      }
    }

    async function send(){
      const text = input.value.trim();
      if(!text) return;

      addMsg(text, 'user');
      saveLocalHistory('user', text);
      input.value = '';
      btn.disabled = true;

      messages.push({ role: "user", content: text });

      let data;
      try {
        const t = getToken();
        const body = { messages };
        if (t) body.t = t;

        const res = await fetch(CHAT_URL, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          credentials: "include",
          body: JSON.stringify(body)
        });

        if (res.status === 429) {
          const j = await res.json().catch(() => ({}));
          addMsg(`Limite mensal atingido (${j.used}/${j.limit}).`, 'bot');
          if (Array.isArray(j.packages) && j.packages.length > 0) {
            const el = document.createElement('div');
            el.className = 'msg bot';
            const wrap = document.createElement('div');
            wrap.className = 'cta-wrap';
            j.packages.forEach(p => {
              if (!p?.url) return;
              const a = document.createElement('a');
              a.className = 'cta-btn';
              a.href = p.url;
              a.target = '_blank';
              a.rel = 'noopener noreferrer';
              a.textContent = p.label || 'Comprar';
              wrap.appendChild(a);
            });
            el.appendChild(wrap);
            chat.appendChild(el);
            chat.scrollTop = chat.scrollHeight;
          }
          btn.disabled = false;
          await atualizarQuota();
          return;
        }

        if(!res.ok){
          const j = await res.json().catch(() => ({}));
          console.error('Falha /api/chat', res.status, j);
          addMsg("Erro no servidor. Tente novamente.", 'bot');
          btn.disabled = false;
          return;
        }

        data = await res.json();
      } catch (err) {
        console.error('Erro de rede /api/chat:', err);
        addMsg("Erro de rede. Tente novamente.", 'bot');
        btn.disabled = false;
        return;
      }

      const reply = data.reply || "(sem conte√∫do)";
      addMsg(reply, 'bot');
      saveLocalHistory('assistant', reply);
      messages.push({ role: "assistant", content: reply });

      btn.disabled = false;
      atualizarQuota();
    }

    btn.addEventListener('click', send);
    input.addEventListener('keydown', e => { if(e.key === 'Enter') send(); });

    input.addEventListener('focus', () => {
      setTimeout(() => {
        chat.scrollTop = chat.scrollHeight;
      }, 250);
    });

    function activateTab(which) {
      if (!panelChat || !panelSpeak || !tabChat || !tabSpeaking) return;
      activeTab = which;
      if (which === 'chat') {
        panelChat.classList.add('active');
        panelSpeak.classList.remove('active');
        tabChat.classList.add('active');
        tabSpeaking.classList.remove('active');
      } else {
        panelChat.classList.remove('active');
        panelSpeak.classList.add('active');
        tabChat.classList.remove('active');
        tabSpeaking.classList.add('active');
      }
      updateBadge();
    }

    tabChat?.addEventListener('click', () => activateTab('chat'));
    tabSpeaking?.addEventListener('click', () => activateTab('speaking'));

    function base64ToBlob(base64, mimeType) {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new Blob([bytes], { type: mimeType || "audio/mpeg" });
    }

    async function sendToSpeakingAPI(blob) {
      if (!speechStatus) return;

      try {
        speechStatus.textContent = 'Enviando √°udio para corre√ß√£o...';

        const arrayBuffer = await blob.arrayBuffer();
        let binary = '';
        const bytes = new Uint8Array(arrayBuffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        const base64 = btoa(binary);

        const t = getToken();
        const payload = { audio: base64 };
        if (t) payload.t = t;

        const res = await fetch(SPEAKING_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify(payload),
        });

        if (!res.ok) {
          if (res.status === 401) {
            speechStatus.textContent = 'Abra esta atividade pelo Canvas para usar o lab de fala.';
            return;
          }
          if (res.status === 429) {
            const j = await res.json().catch(() => ({}));
            speechStatus.textContent = (j && j.message) || 'Voc√™ atingiu o limite de pr√°tica de √°udio.';

            if (speechUsage && j && typeof j.usedMinutes === 'number' && typeof j.limitMinutes === 'number') {
              const usedStr  = j.usedMinutes.toFixed(1).replace('.', ',');
              const limitStr = j.limitMinutes.toFixed(0);
              const label    = `Restante: ${usedStr} / ${limitStr} minutos`;
              speechUsage.textContent = label;
              audioUsage = {
                usedSeconds: j.usedMinutes * 60,
                limitSeconds: j.limitMinutes * 60,
                label
              };
              if (activeTab === 'speaking') {
                updateBadge();
              }
            }
            return;
          }
          const j = await res.json().catch(() => ({}));
          console.error('Erro /api/speaking', res.status, j);
          speechStatus.textContent = 'Erro ao enviar o √°udio para corre√ß√£o.';
          return;
        }

        const data = await res.json().catch(() => ({}));
        const {
          transcript,
          correct_sentence,
          feedback_text,
          audioBase64,
          usedSeconds,
          limitSeconds
        } = data || {};

        let msg = '';
        if (transcript) {
          msg += `Voc√™ disse (aprox.): "${transcript}"\n`;
        }
        if (correct_sentence) {
          msg += `Frase correta: "${correct_sentence}"\n`;
        }
        if (feedback_text) {
          msg += `Dica: ${feedback_text}`;
        }

        speechStatus.textContent = msg || 'Corre√ß√£o recebida, mas vazia.';

        if (typeof usedSeconds === 'number' && typeof limitSeconds === 'number') {
          const usedMin  = usedSeconds / 60;
          const limitMin = limitSeconds / 60;
          const usedStr  = formatMinutes(usedMin);
          const limitStr = limitMin.toFixed(0);
          const label    = `Restante: ${usedStr} / ${limitStr} minutos`;
          if (speechUsage) speechUsage.textContent = label;
          audioUsage = { usedSeconds, limitSeconds, label };
          if (activeTab === 'speaking') {
            updateBadge();
          }
        }

        if (audioBase64 && speechTTS) {
          const ttsBlob = base64ToBlob(audioBase64, "audio/mpeg");
          const ttsUrl  = URL.createObjectURL(ttsBlob);
          speechTTS.src = ttsUrl;
          speechTTS.style.display = 'block';
        }
      } catch (err) {
        console.error('Erro ao enviar √°udio para /api/speaking:', err);
        speechStatus.textContent = 'Erro de rede ao enviar o √°udio.';
      }
    }

    let mediaRecorder = null;
    let chunks = [];
    let isRecording = false;

    async function startRecording(){
      if (!recStart || !recStop || !speechStatus || !speechAudio) return;
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          speechStatus.textContent = 'Seu navegador n√£o suporta grava√ß√£o de √°udio.';
          return;
        }

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        chunks = [];
        isRecording = true;

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            chunks.push(e.data);
          }
        };

        mediaRecorder.onstop = () => {
          try {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            speechAudio.src = url;
            speechAudio.style.display = 'block';
            if (speechTTS) {
              speechTTS.style.display = 'none';
              speechTTS.removeAttribute('src');
            }
            speechStatus.textContent = 'Grava√ß√£o conclu√≠da. Enviando para a IA corrigir sua pron√∫ncia...';

            sendToSpeakingAPI(blob);
          } catch (err) {
            console.error('Erro ao processar √°udio gravado:', err);
            speechStatus.textContent = 'Erro ao processar a grava√ß√£o.';
          }
        };

        mediaRecorder.start();
        speechStatus.textContent = 'Gravando... fale em ingl√™s. Clique em Parar quando terminar.';
        recStart.disabled = true;
        recStop.disabled = false;
      } catch (err) {
        console.error('Erro ao iniciar grava√ß√£o:', err);
        speechStatus.textContent = 'N√£o foi poss√≠vel acessar o microfone. Verifique as permiss√µes do navegador.';
      }
    }

    function stopRecording(){
      if (!recStart || !recStop || !speechStatus) return;
      if (mediaRecorder && isRecording) {
        mediaRecorder.stop();
        isRecording = false;
        recStart.disabled = false;
        recStop.disabled = true;
      }
    }

    recStart?.addEventListener('click', startRecording);
    recStop?.addEventListener('click', stopRecording);

    captureTokenFromURL();
    loadLocalHistory();
    atualizarQuota();     // isso vai preencher lastQuota e atualizar o badge do Chat
    updateBadge();        // garante um estado inicial consistente
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
</body>
</html>
